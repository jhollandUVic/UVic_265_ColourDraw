<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Assign_03_Notes</title>
	<meta name="generator" content="BBEdit 11.6" />
	<style type="text/css">

		body	{	color: navy; 
						background-color: gray;
					 	font-family: Helvetica, Univers, sans-serif;
					}
		code {color: #006600; font-family: "Lucida Console", Courier, "Andale Mono", monospace}
		h1 {color: navy; font-style: oblique; text-shadow: 2px 2px 2px lightgray}
		h2 {color: navy; font-style: italic; text-shadow: 1px 1px 1px lightgray}
		h3 {color: navy; font-style: normal; text-shadow: 1px 1px 1px lightgray}
		h4 {color: navy; font-style: normal; text-shadow: 1px 1px 1px lightgray}

		a:link {color: mediumblue; text-decoration: none}
		a:visited {color: purple; text-decoration: none}
		a:hover {color: red; text-decoration: underline}
		a:active {color: black; text-decoration: none}

	 dl {
			border: 3px solid lightgray;
			padding: 0.5em;
		}
		dt {
			font-weight: bold;
			text-decoration: underline;
		}
		dd {
			margin: 0;
			padding: 0 0 0.5em 0;
		}

	pre, code, tt {
		font-size: 16px;
		font-family: Consolas, "Liberation Mono", Courier, monospace;
	}

	code, tt {
		margin: 0 0px;
		padding: 0px 0px;
		white-space: wrap;
		border: 1px solid #eaeaea;
		background-color: #f8f8f8;
		border-radius: 3px;
	}

	pre>code {
		margin: 0;
		padding: 0;
		white-space: pre;
		border: none;
		background: transparent;
	}

	pre {
		background-color: #f8f8f8;
		border: 1px solid #ccc;
		font-size: 16px;
		line-height: 20px;
		overflow: auto;
		padding: 6px 10px;
		border-radius: 3px;
	}

	pre code, pre tt {
		background-color: transparent;
		border: none;
	}

	table.main {	width: 600px;
					padding: 1px;
					spacing: 2px;
					border: 2px dotted lightgray;
					border-radius: 15px;
					border-spacing: 8px;
					margin-right: auto;
					margin-left: auto;
				}
	table.data	{
	background-color: lightgray;
		width: 600px;
					padding: 1px;
					spacing: 2px;

					margin-right: auto;
					margin-left: auto;
							}
		th {background-color: white; color: navy}
		tr.header {background-color: white}

		td {	font_weight: bold;
					color: navy;
					background-color: white;
					padding: 0px 10px;
					border-radius: 10px
				}
		td.picture {background-color: white}

		img {	display: block;
					margin-right: auto;
					margin-left: auto;
					background-color: white; padding: 3px; border: 1px dotted navy;
				}
</style>

</head>
<body>
<table class="main">
<tr>
<td>




<h1>265Draw: Sierpinski Carpet</h1>

<hr />

<h2>Drawing</h2>

<ul>
<li>Recursion hard-coded at moment but could be controlled by user input</li>
<li>Tiling and rotation also hard-coded.</li>
<li><p>Colour coming.</p></li>
<li><p>Sierpinski Carpet With Four Levels of Recursion:</p></li>
</ul>

<p><img src="image/carpet4.svg" alt="Carpet With Four Levels of Recursion" title="28089 Lines" /></p>

<ul>
<li>Tiled Sierpinski Carpets With Two Levels of Recursion:</li>
</ul>

<p><img src="image/carpet_2ST.svg" alt="Tiled Carpets With Two Levels of Recursion" title="3945 Lines" /></p>

<h2>Code:</h2>

<ul>
<li><p><code>generate_carpet.py</code></p>

<pre><code>import sys
import math
import Line_Point
#
'''
purpose
    write to stdout a Sierpinski Carpet in a 500 x 500 canvas
    with arbitrary recursion level r
preconditions
    r is a positive integer
reference
    See &lt;http://lodev.org/cgtutor/sierpinski.html&gt;
'''
StepColour = ['Red', 'Blue', 'Green', 'Red', 'Orange', 'Lime', 'Maroon']
#
def drawRect(x1, y1, x2, y2, colour):
    # Draw boundaries of square
    point0 = Line_Point.Point(x1, y1)
    point1 = Line_Point.Point(x2,y1)
    line = Line_Point.Line(point0, point1)
    print 'line', line, colour
    point0 = Line_Point.Point(x2,y1)
    point1 = Line_Point.Point(x2, y2)
    line = Line_Point.Line(point0, point1)
    print 'line', line, colour
    point0 = Line_Point.Point(x2, y2)
    point1 = Line_Point.Point(x1, y2)
    line = Line_Point.Line(point0, point1)
    print 'line', line, colour
    point0 = Line_Point.Point(x1, y2)
    point1 = Line_Point.Point(x1, y1)
    line = Line_Point.Line(point0, point1)
    print 'line', line, colour
    # Draw cross on square
    point0 = Line_Point.Point(x1, y2)
    point1 = Line_Point.Point(x2, y1)
    line = Line_Point.Line(point0, point1)
    print 'line', line, colour
    point0 = Line_Point.Point(x1, y1)
    point1 = Line_Point.Point(x2, y2)
    line = Line_Point.Line(point0, point1)
    print 'line', line, colour
#
def drawCarpet(this_step, x1, y1, x2, y2, colour):
    # Determine new rectangle 1/3rd the size in center of given coordinates
    r_x1 = (2 * x1 + x2)/3.0
    r_y1 = (2 * y1 + y2)/3.0
    r_x2 = (x1 + 2 * x2)/3.0
    r_y2 = (y1 + 2 * y2)/3.0
    drawRect(r_x1, r_y1, r_x2, r_y2, colour)
#
    # Call drawCarpet another 8 times, once for each of the rectangles
    # around the one that was just drawn.
    if this_step &gt; 0:
        next_step = this_step - 1
        colour = StepColour[next_step]
        drawCarpet(next_step,   x1,   y1, r_x1, r_y1, colour)
        drawCarpet(next_step, r_x1,   y1, r_x2, r_y1, colour)
        drawCarpet(next_step, r_x2,   y1,   x2, r_y1, colour)
        drawCarpet(next_step,   x1, r_y1, r_x1, r_y2, colour)
        drawCarpet(next_step, r_x2, r_y1,   x2, r_y2, colour)
        drawCarpet(next_step,   x1, r_y2, r_x1,   y2, colour)
        drawCarpet(next_step, r_x1, r_y2, r_x2,   y2, colour)
        drawCarpet(next_step, r_x2, r_y2,   x2,   y2, colour)
#
# ********** process the command line arguments
if len(sys.argv) != 2:
    print &gt;&gt; sys.stderr, 'Syntax: ' + sys.argv[0] + 'recursion_steps'
    sys.exit(1)
try:
    recursion_steps = int(sys.argv[1])
except ValueError:
    print &gt;&gt; sys.stderr, 'Value Error: ' + sys.argv[0] + 'recursion_steps'
    sys.exit(2)
if recursion_steps &gt;= 9:
    print &gt;&gt; sys.stderr, 'Values: ' + sys.argv[0] + 'recursion_steps'
    sys.exit(3)
# Dimensions chosen so side of carpet divisible by 3.
drawCarpet(recursion_steps,-249, 249, 249, -249, StepColour[recursion_steps])
</code></pre></li>
<li><p><code>transform_carpet.py</code></p>

<pre><code>'''
source
    Modified from rings.py
purpose
    Read a file from stdin: a shape consisting of a list of lines.
    Write to stdout a variety of copies of a Sierpinski Carpet.
    Each carpet consists of the lines in the original carpet arranged
    in tiles, possibly rotated, around the origin.
preconditions
    stdin contains a legal line file with colour
'''
#
import sys
import copy
import math
import Line_Point
#
'''
purpose
    write to stdout a set of coloured tiles consisting of 8 copies of the
    original shape in lines, translated horizontally by delta_x,
    vertically by delta_y, rotated by rotation, and scaled to fit in space.
preconditions
    lines is a list with a sublist for each line containing the
    four line coordinates plus a colour
    n &gt; 0
'''
def draw_tile(lines, delta_x, delta_y, rotation, scale):
    new_lines = copy.deepcopy(lines)
#
    for line in new_lines:
        # line is a list with the four line coordinates plus a colour
        point0 = Line_Point.Point(float(line[0]), float(line[1]))
        point1 = Line_Point.Point(float(line[2]), float(line[3]))
        line_object = Line_Point.Line(point0, point1)
        colour = str(line[4])
#
        # Apply transformations
        line_object.rotate(rotation)
        line_object.scale(scale)
        line_object.translate(delta_x, delta_y)
#       
        print 'line', line_object, colour
#
'''
purpose
    convert the lines in stdin to a list containing, for each line,
    a sublist of line coordinates plus colour
    return the list
preconditions
    file_object is a reference to a readable file containing legal lines
'''
def load_line_file(file_object):
    line_objects = [ ]
    for line in file_object:
        # Convert text line to a list with line coordinates and colour
        line_object = line.split()
        this_line_list = [ float(line_object[1]), float(line_object[2]), \
        float(line_object[3]), float(line_object[4]), str(line_object[5]) ]
        line_objects.append(this_line_list)
#
    return line_objects
#
# ***** process command line arguments
#
# if len(sys.argv) != 2:
#   print &gt;&gt; sys.stderr, 'Syntax: ' + sys.argv[0] + ' number_of_rings'
#   sys.exit(1)
# try:
#   number_of_rings = int(sys.argv[1])
# except ValueError:
#   print &gt;&gt; sys.stderr, 'Syntax: ' + sys.argv[0] + ' number_of_rings'
#   sys.exit(2)
# if number_of_rings &lt; 1 or number_of_rings &gt; 5:
#   print &gt;&gt; sys.stderr, 'Syntax: ' + sys.argv[0] + ' number_of_rings'
#   sys.exit(3)
number_of_tiles = 9
angle = math.pi/4
#   Calc height of bounding box of rotated square then invert
#   for amount to scale down to fit in space.
scale = 1 / ( abs(math.sin(angle)) + abs(math.cos(angle)) )
#
L = load_line_file(sys.stdin)
#
# ***** generate the rings
# First tile is in middle, ie. original tile
# Second Tile is above the first
# The succeeding tiles are positioned counterclockwise around original
# delta-x and delta-y relative to origin: center of canvas.
tile_position = [
#   delta-x, delta-y, rotation, scale
#   Angle and Scale setting for "Up, Down, Across" rotated pattern
    [+0.0,      +0.0,   0.0, 1.0],
    [0.0,       +166.0, angle, scale],
    [-166.0,    +166.0, 0.0, 1.0],
    [-166.0,    0.0,    angle, scale],
    [-166.0,    -166.0, 0.0, 1.0],
    [0.0,       -166.0, angle, scale],
    [+166.0,    -166.0, 0.0, 1.0],
    [+166.0,    0.0,    angle, scale],
    [+166.0,    +166.0, 0.0, 1.0],
#
#   All Rotated Except for Center
#   [+0.0,      +0.0,   0.0, 1.0],
#   [0.0,       +166.0, angle, scale],
#   [-166.0,    +166.0, angle, scale],
#   [-166.0,    0.0,    angle, scale],
#   [-166.0,    -166.0, angle, scale],
#   [0.0,       -166.0, angle, scale],
#   [+166.0,    -166.0, angle, scale],
#   [+166.0,    0.0,    angle, scale],
#   [+166.0,    +166.0, angle, scale],
#
#   Diagonally Rotated Except for Center
#   [+0.0,      +0.0,   0.0, 1.0],
#   [0.0,       +166.0, 0.0, 1.0],
#   [-166.0,    +166.0, angle, scale],
#   [-166.0,    0.0,    0.0, 1.0],
#   [-166.0,    -166.0, angle, scale],
#   [0.0,       -166.0, 0.0, 1.0],
#   [+166.0,    -166.0, angle, scale],
#   [+166.0,    0.0,    0.0, 1.0],
#   [+166.0,    +166.0, angle, scale],
]
#   Draw a tile using tile_position which specifies delta-x,
#   delta-y, scale factor, and angle of rotation.
for i in range(number_of_tiles):
    draw_tile(L, tile_position[i][0], tile_position[i][1], \
        tile_position[i][2], tile_position[i][3])
</code></pre></li>
</ul>

<h2>Usage</h2>

<ul>
<li><p>Create a Recursive Sierpinski Carpet with 2 Levels</p>

<p><code>python generate_carpet.py 2 &gt; carpet_2.txt</code></p></li>
<li><p>Scale carpet lines file down to fit in central third of canvas</p>

<p><code>python rotate_scale_translate.py -f .3333 &lt; carpet_2.txt &gt; carpet_2S.txt</code></p></li>
<li><p>Build some tile patterns from scaled file</p>

<p><code>python transform_carpet.py &lt; carpet_2S.txt &gt; carpet_2ST.txt</code></p></li>
</ul>

<h2>Bugs</h2>

<ul>
<li>No colour so not exciting. Could add colour contrast or allow specification of colour themes when colour is available.</li>
<li>Slow screen drawing when recursion level higher than 4.</li>
<li>Clunky code.</li>
</ul>

<h2>References</h2>

<ul>
<li><a href="http://lodev.org/cgtutor/sierpinski.html">Sierpinski Fractals</a></li>
<li><a href="https://www.w3schools.com/graphics/svg_intro.asp">SVG Tutorial</a></li>
</ul>

<h2>Document Notes</h2>

<ul>
<li>This document built in <a href="http://www.barebones.com/products/bbedit/">BBEdit</a> in <a href="http://daringfireball.net/projects/markdown/">Markdown</a> format, converted to HTML with the <a href="http://daringfireball.net/projects/downloads/Markdown_1.0.1.zip">Markdown Text-to-HTML filter</a>, then inserted into a CSS wrapper.</li>
</ul>

<hr />

<p>Last Update: 2017 March 22 at 06:14:41 PDT</p>










</td>
</tr>
</table>
</body>
</html>

